#!/usr/bin/env python3
"""
Extract vulnerable plugin information from a cluster summary CSV/text report.

The script reads the CSV emitted by ``scan_cluster.py`` (or the corresponding
text report) and writes a concise vulnerability summary per cluster that lists
each plugin alongside the CVEs associated with it. When the source data
identifies versions observed in the cluster that match a CVE's affected range,
the script marks those versions explicitly.
"""

from __future__ import annotations

import argparse
import csv
import re
from pathlib import Path
from typing import Dict, List, Sequence

ENTRY_PATTERN = re.compile(r"^(?P<plugin>[^:]+):\s*(?P<body>.+)$")


def parse_vulnerability_field(raw: str | None) -> Dict[str, Dict[str, object]]:
    """
    Convert the serialized "Vulnerable Plugins" column into a structured mapping.
    """
    if not raw:
        return {}

    records: Dict[str, Dict[str, object]] = {}
    parts = [segment.strip() for segment in raw.split(";") if segment.strip()]
    for entry in parts:
        match = ENTRY_PATTERN.match(entry)
        if not match:
            continue
        plugin = match.group("plugin").strip()
        body = match.group("body").strip()

        matched_versions: List[str] = []
        if "[matched versions:" in body:
            body, tail = body.rsplit("[matched versions:", 1)
            versions = tail.rstrip(" ]")
            matched_versions = [version.strip() for version in versions.split(",") if version.strip()]
            body = body.strip()

        if "(" in body and body.endswith(")"):
            identifier, note = body.split("(", 1)
            identifier = identifier.strip()
            note = "(" + note.strip()
        else:
            identifier = body.strip()
            note = ""

        plugin_entry = records.setdefault(plugin, {"matched": set(), "cves": []})
        plugin_entry["matched"].update(matched_versions)
        plugin_entry["cves"].append({"id": identifier, "note": note})
    return records


def read_clusters(csv_path: Path) -> List[Dict[str, object]]:
    with csv_path.open("r", encoding="utf-8") as handle:
        reader = csv.DictReader(handle)
        return list(reader)


def format_cluster_block(cluster_id: str, data: Dict[str, Dict[str, object]]) -> str:
    lines = [f"Cluster {cluster_id}"]
    if not data:
        lines.append("- No vulnerable plugins recorded.")
        return "\n".join(lines)
    for plugin in sorted(data):
        entry = data[plugin]
        matched = entry["matched"]
        match_suffix = ""
        if matched:
            versions = ", ".join(sorted(matched))
            match_suffix = f" (matched versions: {versions})"
        cve_labels = " ".join(
            f"{{{item['id']} {item['note']}}}".strip()
            for item in entry["cves"]
        )
        lines.append(f"- {plugin}{match_suffix}: {cve_labels or '{no CVE ids recorded}'}")
    return "\n".join(lines)


def build_report(rows: Sequence[Dict[str, object]]) -> str:
    blocks: List[str] = []
    for row in rows:
        cluster_id = str(row.get("cluster id") or row.get("cluster_id") or "Unknown")
        field = row.get("Vulnerable Plugins") or ""
        parsed = parse_vulnerability_field(str(field))
        blocks.append(format_cluster_block(cluster_id, parsed))
    return "\n\n".join(blocks)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate a concise vulnerability report per cluster.")
    parser.add_argument(
        "--csv",
        default="all-3_summary.csv",
        help="Path to the cluster summary CSV (default: all-3_summary.csv).",
    )
    parser.add_argument(
        "--output",
        default="cluster_vulnerabilities.txt",
        help="Path to write the vulnerability summary (default: cluster_vulnerabilities.txt).",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    csv_path = Path(args.csv)
    if not csv_path.exists():
        raise SystemExit(f"CSV not found: {csv_path}")
    rows = read_clusters(csv_path)
    report = build_report(rows)
    output_path = Path(args.output)
    output_path.write_text(report, encoding="utf-8")
    print(f"Wrote vulnerability summary for {len(rows)} clusters to {output_path}")


if __name__ == "__main__":
    main()
